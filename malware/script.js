// Global state
let isDownloading = false;
let downloadCount = 0;
let chunksDownloaded = 0;
let wasmModule = null;

// DOM elements
const downloadBtn = document.getElementById("downloadBtn");
const downloadText = document.getElementById("downloadText");
const downloadCounts = document.getElementById("downloadCounts");
const fileCount = document.getElementById("fileCount");
const chunkCount = document.getElementById("chunkCount");
const downloadStatus = document.getElementById("downloadStatus");
const statusText = document.getElementById("statusText");

// Initialize event listeners and simulated WebAssembly
document.addEventListener("DOMContentLoaded", function () {
  downloadBtn.addEventListener("click", handleDownloadEicar);
  initializeWebAssembly();
});

// Initialize simulated WebAssembly module
async function initializeWebAssembly() {
  try {
    // Simulate WebAssembly module with JavaScript
    wasmModule = {
      instance: {
        exports: {
          memory: new ArrayBuffer(1024 * 64), // 64KB simulated memory
          assembleChunks: function (chunks) {
            // Simulated WASM assembly function
            return chunks.map((chunk) => atob(chunk)).join("");
          },
        },
      },
    };
    console.log("Simulated WebAssembly module initialized successfully");
  } catch (error) {
    console.error("Failed to initialize simulated WebAssembly:", error);
  }
}

// Helper function to delay execution
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// Update UI elements
function updateDownloadStatus(status) {
  statusText.textContent = status;
  downloadStatus.style.display = status ? "block" : "none";
}

function updateChunkCount(count) {
  chunksDownloaded = count;
  chunkCount.textContent = `Chunks downloaded: ${count}/3`;
  if (count > 0) {
    downloadCounts.style.display = "block";
  }
}

function updateFileCount(count) {
  downloadCount = count;
  fileCount.textContent = `Files downloaded: ${count}`;
  downloadCounts.style.display = "block";
}

// Simulate fetching chunk data (client-side only)
async function fetchChunk(chunkId) {
  try {
    // Simulate network delay
    await delay(300 + Math.random() * 500);

    // Simulated chunk data (Base64 encoded EICAR parts)
    const chunks = {
      1: {
        chunkId: 1,
        data: "WDVPIVAlQEFQWzRcUFpYNTQoUF4pN0NDKTd9JA==", // X5O!P%@AP[4\PZX54(P^)7CC)7}$
        raw_size: 28,
        encoded_size: 40,
        encoding: "base64",
        checksum: "abc123",
      },
      2: {
        chunkId: 2,
        data: "RUlDQVItU1RBTkRBUkQtQU5USVZJUlVTLQ==", // EICAR-STANDARD-ANTIVIRUS-
        raw_size: 26,
        encoded_size: 36,
        encoding: "base64",
        checksum: "def456",
      },
      3: {
        chunkId: 3,
        data: "VEVTVC1GSUxFISRIK0gq", // TEST-FILE!$H+H*
        raw_size: 14,
        encoded_size: 20,
        encoding: "base64",
        checksum: "ghi789",
      },
    };

    if (!chunks[chunkId]) {
      throw new Error(`Chunk ${chunkId} not found`);
    }

    console.log(`Simulated chunk ${chunkId} fetch successful`);
    return chunks[chunkId];
  } catch (error) {
    console.error(`Error fetching chunk ${chunkId}:`, error);
    throw error;
  }
}

// Get chunk information (client-side simulation)
async function getChunkInfo() {
  try {
    // Simulate network delay
    await delay(200);

    // Simulated chunk info
    const chunkInfo = {
      totalChunks: 3,
      encoding: "base64",
      description: "EICAR test file fragments",
      assemblyRequired: true,
      wasmRequired: true,
    };

    console.log("Simulated chunk info retrieved:", chunkInfo);
    return chunkInfo;
  } catch (error) {
    console.error("Error getting chunk info:", error);
    throw error;
  }
}

// Assemble chunks using simulated WebAssembly
function assembleChunksWithWASM(chunks) {
  if (!wasmModule) {
    throw new Error("Simulated WebAssembly module not loaded");
  }

  try {
    console.log("Using simulated WebAssembly assembly...");

    // Use the simulated WASM function
    const result = wasmModule.instance.exports.assembleChunks(chunks);

    console.log("Simulated WASM assembly complete, result:", result);
    return result;
  } catch (error) {
    console.error("Simulated WebAssembly assembly failed:", error);
    throw error;
  }
}

// Fallback assembly function (if WASM fails)
function assembleChunksFallback(chunks) {
  console.log("Using fallback assembly for chunks:", chunks.length);
  try {
    const decodedChunks = chunks.map((chunk, index) => {
      console.log(
        `Decoding chunk ${index + 1}:`,
        chunk.substring(0, 20) + "...",
      );
      return atob(chunk); // Decode Base64
    });
    const result = decodedChunks.join("");
    console.log("Fallback assembly result:", result);
    return result;
  } catch (error) {
    console.error("Fallback assembly failed:", error);
    throw error;
  }
}

// Main download handler
async function handleDownloadEicar() {
  if (isDownloading) return;

  isDownloading = true;
  chunksDownloaded = 0;
  downloadBtn.disabled = true;
  downloadText.textContent = "Assembling...";
  updateDownloadStatus("Initializing...");

  try {
    // Get chunk information from server
    updateDownloadStatus("Getting chunk information...");
    const chunkInfo = await getChunkInfo();
    const totalChunks = chunkInfo.totalChunks;

    updateDownloadStatus("Loading WebAssembly module...");
    // Ensure simulated WASM is loaded
    if (!wasmModule) {
      await initializeWebAssembly();
    }
    await delay(300);

    // Fetch chunks from server one by one
    let fetchedChunks = [];

    for (let i = 1; i <= totalChunks; i++) {
      updateDownloadStatus(`Downloading chunk ${i}/${totalChunks}...`);

      // Fetch chunk from server
      const chunkData = await fetchChunk(i);
      console.log(`Received chunk ${i}:`, {
        chunkId: chunkData.chunkId,
        size: chunkData.encoded_size,
        encoding: chunkData.encoding,
      });

      fetchedChunks.push(chunkData.data);
      updateChunkCount(i);

      // Simulate processing time between chunks
      await delay(400);
    }

    console.log(`Successfully downloaded ${fetchedChunks.length} chunks`);
    console.log(
      "Chunk data:",
      fetchedChunks.map(
        (chunk, i) => `Chunk ${i + 1}: ${chunk.substring(0, 10)}...`,
      ),
    );

    updateDownloadStatus("Assembling payload with WebAssembly...");
    await delay(500);

    // Assemble chunks using WebAssembly
    let assembledContent;
    try {
      console.log("Attempting WebAssembly assembly...");
      assembledContent = assembleChunksWithWASM(fetchedChunks);
      console.log(
        "WebAssembly assembly successful, result length:",
        assembledContent.length,
      );
      console.log(
        "Assembled content preview:",
        assembledContent.substring(0, 50),
      );
      updateDownloadStatus("WebAssembly assembly complete!");
    } catch (wasmError) {
      console.warn("WebAssembly assembly failed, using fallback:", wasmError);
      updateDownloadStatus("WASM failed, using fallback assembly...");
      assembledContent = assembleChunksFallback(fetchedChunks);
    }

    if (!assembledContent) {
      throw new Error("Failed to assemble chunks - no content generated");
    }

    await delay(300);

    // Create and download the reconstructed file
    const blob = new Blob([assembledContent], {
      type: "application/octet-stream",
    });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "eicar.com";
    link.style.display = "none";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);

    updateDownloadStatus("Complete!");
    updateFileCount(downloadCount + 1);

    // Log download attempt to server
    logDownloadAttempt();

    setTimeout(() => {
      updateDownloadStatus("");
      resetDownloadState();
    }, 1000);
  } catch (error) {
    console.error("Failed to assemble EICAR test file:", error);
    updateDownloadStatus("Download failed, using emergency fallback...");

    // Emergency fallback to simple download
    const eicarString =
      "X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*";
    const blob = new Blob([eicarString], { type: "text/plain" });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "eicar.com";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);

    updateFileCount(downloadCount + 1);

    setTimeout(() => {
      updateDownloadStatus("");
      resetDownloadState();
    }, 1000);
  }
}

function resetDownloadState() {
  isDownloading = false;
  downloadBtn.disabled = false;
  downloadText.textContent = "Download EICAR Test File";
  // Keep chunk count visible after download
}

// Client-side storage functions
function getDownloadStats() {
  try {
    const logs = JSON.parse(localStorage.getItem("eicarDownloadLogs") || "[]");
    const today = new Date().toDateString();
    const todayLogs = logs.filter(
      (log) => new Date(log.timestamp).toDateString() === today,
    );

    return {
      totalDownloads: logs.length,
      todayDownloads: todayLogs.length,
      lastDownload: logs.length > 0 ? logs[logs.length - 1].timestamp : null,
    };
  } catch (error) {
    console.error("Error getting download stats:", error);
    return { totalDownloads: 0, todayDownloads: 0, lastDownload: null };
  }
}

// Log download attempts (client-side only)
async function logDownloadAttempt() {
  const logData = {
    timestamp: new Date().toISOString(),
    userAgent: navigator.userAgent,
    downloadCount: downloadCount,
    chunksProcessed: chunksDownloaded,
    assemblyMethod: wasmModule ? "Simulated WebAssembly" : "Fallback",
  };

  // Store in localStorage for demonstration
  try {
    const existingLogs = JSON.parse(
      localStorage.getItem("eicarDownloadLogs") || "[]",
    );
    existingLogs.push(logData);
    localStorage.setItem("eicarDownloadLogs", JSON.stringify(existingLogs));
    console.log("Download attempt logged locally:", logData);
  } catch (error) {
    console.error("Failed to log download attempt:", error);
  }
}

// Optional: Add visual feedback for chunk assembly process
function showAssemblyProgress() {
  // Could add visual indicators for WASM assembly process
  console.log("Assembly in progress...");
}
