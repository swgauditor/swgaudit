<?php
// Enable error reporting for debugging
error_reporting(E_ALL);
ini_set('display_errors', 0); // Don't display errors in response
ini_set('log_errors', 1);

// Set content type to JSON for all responses
header('Content-Type: application/json');
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: POST, GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type');

// Handle preflight requests
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    echo json_encode(['success' => true, 'message' => 'CORS preflight']);
    exit(0);
}

// Simple logging functionality
class EICarLogger {
    private $logFile = 'downloads.log';
    
    public function logDownload($data) {
        $timestamp = date('Y-m-d H:i:s');
        $ip = $_SERVER['REMOTE_ADDR'] ?? 'unknown';
        $userAgent = $_SERVER['HTTP_USER_AGENT'] ?? 'unknown';
        
        $logEntry = [
            'timestamp' => $timestamp,
            'ip' => $ip,
            'userAgent' => $userAgent,
            'downloadCount' => $data['downloadCount'] ?? 0,
            'chunksProcessed' => $data['chunksProcessed'] ?? 0,
            'assemblyMethod' => $data['assemblyMethod'] ?? 'unknown',
            'status' => 'success'
        ];
        
        $logLine = date('Y-m-d H:i:s') . " - " . json_encode($logEntry) . "\n";
        file_put_contents($this->logFile, $logLine, FILE_APPEND | LOCK_EX);
        
        return $logEntry;
    }
    
    public function getStats() {
        if (!file_exists($this->logFile)) {
            return ['totalDownloads' => 0, 'todayDownloads' => 0];
        }
        
        $logs = file($this->logFile, FILE_IGNORE_NEW_LINES);
        $totalDownloads = count($logs);
        
        $today = date('Y-m-d');
        $todayDownloads = 0;
        
        foreach ($logs as $log) {
            if (strpos($log, $today) === 0) {
                $todayDownloads++;
            }
        }
        
        return [
            'totalDownloads' => $totalDownloads,
            'todayDownloads' => $todayDownloads,
            'lastUpdated' => date('Y-m-d H:i:s')
        ];
    }
}

// Chunk data (EICAR test file split into 3 parts)
class ChunkManager {
    private $chunks = [
        1 => 'X5O!P%@AP[4\\PZX54(P^)7CC)7}$', // First part of EICAR
        2 => 'EICAR-STANDARD-ANTIVIRUS-',      // Middle part
        3 => 'TEST-FILE!$H+H*'                 // Final part
    ];
    
    public function getChunk($chunkId) {
        if (!isset($this->chunks[$chunkId])) {
            throw new Exception('Chunk not found');
        }
        
        // Simulate realistic network delay
        usleep(rand(200000, 800000)); // 200-800ms delay
        
        $rawData = $this->chunks[$chunkId];
        $encodedData = base64_encode($rawData);
        
        return [
            'chunkId' => $chunkId,
            'data' => $encodedData, // Base64 encoded for safe transport
            'raw_size' => strlen($rawData),
            'encoded_size' => strlen($encodedData),
            'encoding' => 'base64',
            'checksum' => md5($rawData),
            'timestamp' => microtime(true)
        ];
    }
    
    public function getTotalChunks() {
        return count($this->chunks);
    }
    
    public function getChunkInfo() {
        return [
            'totalChunks' => $this->getTotalChunks(),
            'encoding' => 'base64',
            'description' => 'EICAR test file fragments',
            'assemblyRequired' => true,
            'wasmRequired' => true,
            'chunkSizes' => array_map('strlen', $this->chunks),
            'totalSize' => array_sum(array_map('strlen', $this->chunks))
        ];
    }
}

// Rate limiting class
class RateLimiter {
    private $requestsFile = 'requests.log';
    private $maxRequestsPerMinute = 30;
    
    public function checkRateLimit() {
        $ip = $_SERVER['REMOTE_ADDR'] ?? 'unknown';
        $currentTime = time();
        $cutoffTime = $currentTime - 60; // 1 minute ago
        
        // Read existing requests
        $requests = [];
        if (file_exists($this->requestsFile)) {
            $lines = file($this->requestsFile, FILE_IGNORE_NEW_LINES);
            foreach ($lines as $line) {
                $data = json_decode($line, true);
                if ($data && $data['timestamp'] > $cutoffTime) {
                    $requests[] = $data;
                }
            }
        }
        
        // Count requests from this IP in the last minute
        $ipRequests = array_filter($requests, function($req) use ($ip) {
            return $req['ip'] === $ip;
        });
        
        if (count($ipRequests) >= $this->maxRequestsPerMinute) {
            return false;
        }
        
        // Log this request
        $logEntry = [
            'ip' => $ip,
            'timestamp' => $currentTime,
            'endpoint' => $_SERVER['REQUEST_URI'] ?? ''
        ];
        
        file_put_contents($this->requestsFile, json_encode($logEntry) . "\n", FILE_APPEND | LOCK_EX);
        
        // Clean up old entries
        $validRequests = array_filter($requests, function($req) use ($cutoffTime) {
            return $req['timestamp'] > $cutoffTime;
        });
        $validRequests[] = $logEntry;
        
        $content = implode("\n", array_map('json_encode', $validRequests)) . "\n";
        file_put_contents($this->requestsFile, $content, LOCK_EX);
        
        return true;
    }
}

// Initialize classes
$logger = new EICarLogger();
$chunkManager = new ChunkManager();
$rateLimiter = new RateLimiter();

try {
    // Check rate limit
    if (!$rateLimiter->checkRateLimit()) {
        http_response_code(429);
        echo json_encode([
            'success' => false,
            'message' => 'Rate limit exceeded. Please wait before making more requests.',
            'error_code' => 'RATE_LIMIT_EXCEEDED'
        ]);
        exit;
    }
    
    switch ($_SERVER['REQUEST_METHOD']) {
        case 'POST':
            // Log download attempt
            $input = json_decode(file_get_contents('php://input'), true);
            
            if (json_last_error() !== JSON_ERROR_NONE) {
                throw new Exception('Invalid JSON input: ' . json_last_error_msg());
            }
            
            $result = $logger->logDownload($input);
            
            echo json_encode([
                'success' => true,
                'message' => 'Download logged successfully',
                'data' => $result
            ]);
            break;
            
        case 'GET':
            // Handle different GET endpoints
            if (isset($_GET['chunk'])) {
                // Serve individual chunk
                $chunkId = intval($_GET['chunk']);
                
                if ($chunkId < 1 || $chunkId > $chunkManager->getTotalChunks()) {
                    throw new Exception('Invalid chunk ID');
                }
                
                $chunkData = $chunkManager->getChunk($chunkId);
                
                echo json_encode([
                    'success' => true,
                    'data' => $chunkData,
                    'message' => "Chunk {$chunkId} retrieved successfully"
                ]);
                
            } elseif (isset($_GET['info'])) {
                // Get chunk information
                $chunkInfo = $chunkManager->getChunkInfo();
                
                echo json_encode([
                    'success' => true,
                    'data' => $chunkInfo,
                    'message' => 'Chunk information retrieved successfully'
                ]);
                
            } elseif (isset($_GET['stats'])) {
                // Get download statistics
                $stats = $logger->getStats();
                
                echo json_encode([
                    'success' => true,
                    'data' => $stats,
                    'message' => 'Statistics retrieved successfully'
                ]);
                
            } elseif (isset($_GET['health'])) {
                // Health check endpoint
                echo json_encode([
                    'success' => true,
                    'message' => 'Service is healthy',
                    'data' => [
                        'status' => 'healthy',
                        'timestamp' => date('Y-m-d H:i:s'),
                        'version' => '1.0.0',
                        'chunks_available' => $chunkManager->getTotalChunks()
                    ]
                ]);
                
            } else {
                // Default: Get download statistics
                $stats = $logger->getStats();
                
                echo json_encode([
                    'success' => true,
                    'message' => 'Default statistics endpoint',
                    'data' => $stats
                ]);
            }
            break;
            
        default:
            throw new Exception('Method not allowed: ' . $_SERVER['REQUEST_METHOD']);
    }
    
} catch (Exception $e) {
    http_response_code(400);
    echo json_encode([
        'success' => false,
        'message' => $e->getMessage(),
        'error_code' => 'GENERAL_ERROR',
        'timestamp' => date('Y-m-d H:i:s')
    ]);
}
?>
